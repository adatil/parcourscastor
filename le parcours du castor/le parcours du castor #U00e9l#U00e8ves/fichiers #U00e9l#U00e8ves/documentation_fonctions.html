<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Documentation technique - Parcours du Castor</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        h1 {
            color: #2c5aa0;
            border-bottom: 3px solid #2c5aa0;
            padding-bottom: 10px;
        }
        h2 {
            color: #3d7ac8;
            margin-top: 30px;
            border-left: 4px solid #3d7ac8;
            padding-left: 15px;
        }
        h3 {
            color: #5a92d4;
            margin-top: 20px;
        }
        h4 {
            color: #4a7ba7;
            margin-top: 15px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #2c5aa0;
            color: white;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #c7254e;
        }
        pre {
            background-color: #282c34;
            color: #abb2bf;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            line-height: 1.4;
        }
        pre code {
            background-color: transparent;
            color: #abb2bf;
            padding: 0;
        }
        .section {
            background-color: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .note {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
        .important {
            background-color: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
        .tip {
            background-color: #d1ecf1;
            border-left: 4px solid #17a2b8;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
        ul, ol {
            margin: 10px 0;
            padding-left: 30px;
        }
        li {
            margin: 5px 0;
        }
        hr {
            border: none;
            border-top: 2px solid #ddd;
            margin: 30px 0;
        }
    </style>
</head>
<body>
    <h1>üìö Documentation technique du projet - Parcours du Castor</h1>

    <div class="section">
        <h2>üèóÔ∏è Architecture du projet</h2>
        <p>Le projet est divis√© en deux fichiers Python :</p>
        <ol>
            <li><strong><code>jeucastortravail.py</code></strong> : Logique du jeu (fonctions de validation, chemins, etc.)</li>
            <li><strong><code>interfacecastortravail.py</code></strong> : Interface graphique Tkinter</li>
        </ol>
        <p>Cette s√©paration permet de tester les fonctions de logique ind√©pendamment de l'interface.</p>
    </div>

    <hr>

    <div class="section">
        <h2>üíª Fichier <code>interfacecastortravail.py</code></h2>

        <h3>Variables globales</h3>
        <table>
            <thead>
                <tr>
                    <th>Variable</th>
                    <th>Type</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>SCRIPT_DIR</code></td>
                    <td>str</td>
                    <td>Chemin absolu du dossier contenant le script (pour charger les images)</td>
                </tr>
                <tr>
                    <td><code>fenetre</code></td>
                    <td>Tk</td>
                    <td>Fen√™tre principale de l'application</td>
                </tr>
                <tr>
                    <td><code>maPolice1</code></td>
                    <td>Font</td>
                    <td>Police Arial 18 gras pour les boutons</td>
                </tr>
                <tr>
                    <td><code>photoF, photoB, photoP</code></td>
                    <td>PhotoImage</td>
                    <td>Images des cases (feuille, bois, pierre)</td>
                </tr>
                <tr>
                    <td><code>tableauBoutons</code></td>
                    <td>list</td>
                    <td>Tableau 2D contenant tous les boutons de la grille</td>
                </tr>
                <tr>
                    <td><code>reponse</code></td>
                    <td>StringVar</td>
                    <td>Variable Tkinter pour afficher "Bravo" ou "Perdu"</td>
                </tr>
                <tr>
                    <td><code>commentaire</code></td>
                    <td>Label</td>
                    <td>Label qui affiche le contenu de <code>reponse</code></td>
                </tr>
                <tr>
                    <td><code>validationSaisie</code></td>
                    <td>Button</td>
                    <td>Bouton "Parcours termin√©"</td>
                </tr>
            </tbody>
        </table>

        <h3>Gestion des chemins d'images</h3>
        <p>Pour √©viter les probl√®mes de chemins relatifs, on utilise :</p>
        <pre><code>SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
photoF = PhotoImage(file=os.path.join(SCRIPT_DIR, "feuille.png"))</code></pre>
        <p>Cela garantit que les images seront trouv√©es quelle que soit la fa√ßon dont le script est lanc√©.</p>

        <h3>Fonctions fournies</h3>

        <h4><code>initialise(grilleinit=grille_1)</code></h4>
        <p><strong>But</strong> : Cr√©e l'affichage initial de la grille avec les boutons cliquables.</p>
        <p><strong>Fonctionnement</strong> :</p>
        <ol>
            <li>Calcule les dimensions L√óC de la grille</li>
            <li>Cr√©e un tableau 2D <code>tableauBoutons</code> rempli de 0</li>
            <li>Pour chaque case <code>[x, y]</code> de la grille :
                <ul>
                    <li>Lit le type de case dans <code>grilleinit[x][y]</code> (P, B ou F)</li>
                    <li>Cr√©e un <code>Button</code> avec l'image correspondante</li>
                    <li>Configure le bouton pour appeler <code>clic()</code> avec les bons param√®tres</li>
                    <li>Stocke le bouton dans <code>tableauBoutons[x][y]</code></li>
                    <li>Place le bouton sur la grille avec <code>.grid(row=x, column=y)</code></li>
                </ul>
            </li>
        </ol>
        <div class="note">
            <strong>Note sur les lambda :</strong>
            <pre><code>lambda b=bouton, absc=x, ordon=y: clic(grillecourante, b, absc, ordon, "P")</code></pre>
            <p>Les param√®tres <code>b=bouton</code>, <code>absc=x</code>, <code>ordon=y</code> sont n√©cessaires pour "capturer" les valeurs au moment de la cr√©ation du bouton. Sans √ßa, tous les boutons auraient les m√™mes valeurs finales de <code>x</code> et <code>y</code>.</p>
        </div>

        <h4><code>clic(g, btn, ligne, colon, typecase)</code></h4>
        <p><strong>But</strong> : G√®re le clic sur une case de la grille.</p>
        <p><strong>Fonctionnement</strong> :</p>
        <ol>
            <li>D√©sactive le bouton cliqu√© : <code>btn["state"] = DISABLED</code></li>
            <li>Ajoute les coordonn√©es √† la liste globale <code>chemin</code> : <code>chemin.append([ligne, colon])</code></li>
        </ol>
        <p><strong>Param√®tres</strong> :</p>
        <ul>
            <li><code>g</code> : la grille (non utilis√© ici)</li>
            <li><code>btn</code> : le bouton Tkinter qui a √©t√© cliqu√©</li>
            <li><code>ligne</code>, <code>colon</code> : coordonn√©es de la case</li>
            <li><code>typecase</code> : type de la case ("P", "B" ou "F")</li>
        </ul>

        <h4><code>lanceAide(grille)</code></h4>
        <p><strong>But</strong> : Lance la recherche automatique d'un chemin valide et l'affiche.</p>
        <p><strong>Fonctionnement</strong> :</p>
        <ol>
            <li>Appelle <code>chercheChemin(grille)</code> pour trouver un chemin</li>
            <li>V√©rifie si un chemin a √©t√© trouv√© (non vide et se termine en <code>[0,0]</code>)</li>
            <li>Si oui :
                <ul>
                    <li>D√©sactive tous les boutons du chemin</li>
                    <li>Appelle <code>verification()</code> pour afficher le r√©sultat</li>
                </ul>
            </li>
            <li>Sinon : affiche "Pas de solution trouv√©e !"</li>
        </ol>
        <div class="tip">
            <strong>üí° Utilit√© :</strong> Cette fonction vous montre comment utiliser le r√©sultat d'une fonction de recherche de chemin pour l'afficher sur l'interface.
        </div>
    </div>

    <hr>

    <div class="section">
        <h2>üéÆ Fichier <code>jeucastortravail.py</code></h2>

        <h3>Variables globales</h3>
        <table>
            <thead>
                <tr>
                    <th>Variable</th>
                    <th>Type</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>chemin</code></td>
                    <td>list</td>
                    <td>Liste des cases cliqu√©es <code>[[l1,c1], [l2,c2], ...]</code></td>
                </tr>
                <tr>
                    <td><code>casedep</code></td>
                    <td>list</td>
                    <td>Case de d√©part <code>[5, 4]</code> (pour la grille 5√ó6 par d√©faut)</td>
                </tr>
                <tr>
                    <td><code>casearriv</code></td>
                    <td>list</td>
                    <td>Case d'arriv√©e <code>[0, 0]</code> (haut-gauche)</td>
                </tr>
                <tr>
                    <td><code>grille_1</code></td>
                    <td>list</td>
                    <td>Grille exemple 5√ó6</td>
                </tr>
                <tr>
                    <td><code>grillecourante</code></td>
                    <td>list</td>
                    <td>Grille actuellement utilis√©e</td>
                </tr>
            </tbody>
        </table>
        <div class="note">
            <strong>Note :</strong> Les variables <code>casedep</code> et <code>casearriv</code> sont souvent recalcul√©es dynamiquement dans les fonctions pour s'adapter √† la taille de la grille.
        </div>

        <h3>Repr√©sentation de la grille</h3>
        <p>Une grille est une liste de listes (tableau 2D) :</p>
        <pre><code>grille_1 = [
    ["P","B","P","F","P","P"],  # Ligne 0 (haut)
    ["F","P","P","P","B","B"],  # Ligne 1
    ["P","P","F","P","B","P"],  # Ligne 2
    ["P","B","F","F","F","B"],  # Ligne 3
    ["P","B","P","F","B","F"]   # Ligne 4 (bas)
]</code></pre>
        <ul>
            <li><strong>P</strong> = Pierre ü™®</li>
            <li><strong>B</strong> = Bois ü™µ</li>
            <li><strong>F</strong> = Feuille üçÉ</li>
        </ul>
        <p><strong>Coordonn√©es</strong> : <code>grille[ligne][colonne]</code></p>
        <ul>
            <li>Ligne 0 = haut, Ligne 4 = bas</li>
            <li>Colonne 0 = gauche, Colonne 5 = droite</li>
            <li>Case <code>[0, 0]</code> = haut-gauche (arriv√©e) üèÅ</li>
            <li>Case <code>[4, 5]</code> = bas-droite (d√©part) üöÄ</li>
        </ul>

        <h3>‚ö†Ô∏è Fonctions √† compl√©ter</h3>
        <div class="important">
            <strong>Important :</strong> Dans le fichier √©l√®ve, TOUTES les fonctions de logique sont √† compl√©ter. Seules <code>initialise()</code> et <code>clic()</code> dans l'interface sont fournies.
        </div>

        <h4><code>cheminContinu(parcours)</code> - √Ä COMPL√âTER</h4>
        <p><strong>But</strong> : V√©rifie que toutes les cases du parcours sont adjacentes cons√©cutivement.</p>
        <p><strong>Algorithme sugg√©r√©</strong> :</p>
        <ul>
            <li>Parcourir toutes les paires de cases cons√©cutives</li>
            <li>Pour chaque paire, v√©rifier qu'elles sont voisines avec <code>sontVoisines()</code></li>
            <li>Si une paire n'est pas voisine : retourner <code>False</code></li>
            <li>Si toutes les paires sont voisines : retourner <code>True</code></li>
        </ul>
        <div class="important">
            <strong>‚ö†Ô∏è Pi√®ge √† √©viter :</strong> Le <code>return True</code> doit √™tre <strong>en dehors</strong> de la boucle <code>for</code>. Si on le met dans la boucle, la fonction retournera <code>True</code> d√®s la premi√®re paire voisine test√©e.
        </div>

        <h4><code>casesVoisinesPossibles(grille, cheminParcouru, caseActuelle)</code> - √Ä COMPL√âTER</h4>
        <p><strong>But</strong> : Retourne les cases voisines non encore visit√©es.</p>
        <p><strong>Algorithme sugg√©r√©</strong> :</p>
        <ol>
            <li>Calculer les dimensions de la grille (L lignes, C colonnes)</li>
            <li>G√©n√©rer la liste de toutes les cases de la grille</li>
            <li>√Ä partir de la case actuelle <code>[x, y]</code>, calculer les 4 positions voisines :
                <ul>
                    <li><code>[x-1, y]</code> : au-dessus ‚¨ÜÔ∏è</li>
                    <li><code>[x+1, y]</code> : en-dessous ‚¨áÔ∏è</li>
                    <li><code>[x, y-1]</code> : √† gauche ‚¨ÖÔ∏è</li>
                    <li><code>[x, y+1]</code> : √† droite ‚û°Ô∏è</li>
                </ul>
            </li>
            <li>Filtrer les positions pour ne garder que celles qui :
                <ul>
                    <li>Sont dans la grille (existent dans <code>cases_grille</code>)</li>
                    <li>Ne sont pas d√©j√† dans <code>cheminParcouru</code></li>
                </ul>
            </li>
            <li>Retourner la liste filtr√©e</li>
        </ol>
        <div class="tip">
            <strong>üí° Utilit√© :</strong> Cette fonction sera utilis√©e pour g√©n√©rer les chemins al√©atoires et pour le backtracking.
        </div>

        <h4><code>chercheChemin(grille)</code> - Algorithme de backtracking</h4>
        <p><strong>But</strong> : Recherche un chemin valide avec l'algorithme de backtracking (retour en arri√®re).</p>

        <div class="note">
            <strong>Principe du backtracking :</strong>
            <p>Le backtracking est une technique de recherche exhaustive qui explore toutes les possibilit√©s en :</p>
            <ol>
                <li>Essayant une solution</li>
                <li>Si √ßa fonctionne, on continue</li>
                <li>Si on est bloqu√©, on <strong>revient en arri√®re</strong> et on essaie autre chose</li>
            </ol>
        </div>

        <p><strong>Variables utilis√©es</strong> :</p>
        <ul>
            <li><code>casecourante</code> : position actuelle du castor</li>
            <li><code>chemin</code> : liste des cases parcourues jusqu'ici</li>
            <li><code>culDeSac</code> : liste des chemins test√©s qui ne m√®nent nulle part</li>
            <li><code>nextmove</code> : liste des cases voisines possibles depuis la position actuelle</li>
        </ul>

        <p><strong>D√©roulement</strong> :</p>
        <ol>
            <li>On d√©marre de la case de d√©part</li>
            <li>On cherche les cases voisines valides (qui respectent les r√®gles)</li>
            <li>On essaie la premi√®re case disponible</li>
            <li>Si le chemin actuel est d√©j√† dans <code>culDeSac</code> : on l'ignore</li>
            <li>Si toutes les cases ont √©t√© test√©es (on est bloqu√©) :
                <ul>
                    <li>On m√©morise ce chemin dans <code>culDeSac</code></li>
                    <li>On retire la derni√®re case (<strong>backtrack</strong>)</li>
                    <li>On revient √† la case pr√©c√©dente</li>
                </ul>
            </li>
            <li>On continue jusqu'√† atteindre <code>[0,0]</code> ou √©puiser toutes les possibilit√©s</li>
        </ol>

        <p><strong>Exemple visuel</strong> :</p>
        <pre><code>D√©part [4,5]
‚îú‚îÄ Essai 1 : [4,5] ‚Üí [3,5] ‚Üí [2,5] ‚Üí Bloqu√© ! ‚ùå
‚îÇ  ‚îî‚îÄ Backtrack √† [3,5]
‚îî‚îÄ Essai 2 : [4,5] ‚Üí [3,5] ‚Üí [3,4] ‚Üí ... ‚Üí [0,0] ‚úì</code></pre>

        <h4><code>rechercheCasesVoisinesPossibles(grille, cheminParcouru, caseActuelle)</code></h4>
        <p><strong>But</strong> : Comme <code>casesVoisinesPossibles</code> mais avec filtrage selon la r√®gle d'alternance.</p>
        <p><strong>Diff√©rence cl√©</strong> :</p>
        <ul>
            <li><code>casesVoisinesPossibles</code> : retourne toutes les cases voisines non visit√©es</li>
            <li><code>rechercheCasesVoisinesPossibles</code> : retourne uniquement celles qui respectent aussi la r√®gle du joker</li>
        </ul>
        <p><strong>Fonctionnement</strong> :</p>
        <ol>
            <li>Appelle <code>casesVoisinesPossibles()</code> pour avoir la liste de base</li>
            <li>Pour chaque case de cette liste :
                <ul>
                    <li>Ajoute temporairement la case au chemin</li>
                    <li>Teste si <code>ordreDesCases()</code> est toujours respect√©</li>
                    <li>Si oui, garde la case ; sinon, l'√©limine</li>
                    <li>Retire la case du chemin (test temporaire)</li>
                </ul>
            </li>
            <li>Retourne uniquement les cases valides</li>
        </ol>
        <div class="tip">
            <strong>üí° Utilit√© :</strong> Permet au backtracking de ne tester que les chemins qui ont une chance de r√©ussir.
        </div>
    </div>

    <hr>

    <div class="section">
        <h2>‚úèÔ∏è √Ä compl√©ter : Sp√©cifications techniques</h2>

        <h3>Partie I - Fonctions de validation</h3>

        <h4><code>sontVoisines(case1, case2)</code></h4>
        <p><strong>Sp√©cification</strong> :</p>
        <ul>
            <li><strong>Entr√©e</strong> : Deux cases <code>[ligne, colonne]</code></li>
            <li><strong>Sortie</strong> : <code>True</code> si adjacentes, <code>False</code> sinon</li>
            <li><strong>R√®gle</strong> : Adjacence horizontale ou verticale uniquement (pas diagonale)</li>
        </ul>
        <div class="tip">
            <strong>üí≠ √Ä r√©fl√©chir :</strong>
            <ul>
                <li>Quelle condition math√©matique v√©rifie qu'une case est juste √† c√¥t√© d'une autre ?</li>
                <li>Comment distinguer un voisin direct d'une case en diagonale ?</li>
            </ul>
        </div>

        <h4><code>ordreDesCases(parcours, grilleATester)</code></h4>
        <p><strong>Sp√©cification</strong> :</p>
        <ul>
            <li><strong>Entr√©e</strong> : Un parcours (liste de cases) et une grille</li>
            <li><strong>Sortie</strong> : <code>True</code> si la r√®gle d'alternance est respect√©e avec au plus 1 joker</li>
            <li><strong>R√®gle</strong> : Pas deux cases du m√™me type cons√©cutives, sauf 1 fois maximum</li>
        </ul>
        <p><strong>Algorithme sugg√©r√©</strong> :</p>
        <ol>
            <li>Construire le mot (cha√Æne de caract√®res) correspondant au parcours</li>
            <li>Compter les paires de lettres identiques cons√©cutives</li>
            <li>V√©rifier que ce compteur ‚â§ 1</li>
        </ol>
        <p><strong>Exemple de mot</strong> :</p>
        <ul>
            <li>Parcours <code>[[0,0], [0,1], [1,1]]</code> sur grille o√π <code>[0,0]="P"</code>, <code>[0,1]="B"</code>, <code>[1,1]="B"</code></li>
            <li>Mot : <code>"PBB"</code> ‚Üí 1 paire identique cons√©cutive ‚Üí OK (1 joker)</li>
        </ul>

        <h4><code>departArrivee(parcours, grille)</code></h4>
        <p><strong>Sp√©cification</strong> :</p>
        <ul>
            <li><strong>Entr√©e</strong> : Un parcours et une grille</li>
            <li><strong>Sortie</strong> : <code>True</code> si d√©part = bas-droite ET arriv√©e = haut-gauche</li>
            <li><strong>Calcul dynamique</strong> :
                <ul>
                    <li>D√©part = <code>[len(grille)-1, len(grille[0])-1]</code></li>
                    <li>Arriv√©e = <code>[0, 0]</code></li>
                </ul>
            </li>
        </ul>
        <div class="tip">
            <strong>üí° Astuce :</strong> Acc√®s au premier √©l√©ment avec <code>parcours[0]</code>, au dernier avec <code>parcours[-1]</code>
        </div>

        <h4><code>verification(chemin, grille)</code></h4>
        <p><strong>Sp√©cification</strong> :</p>
        <ul>
            <li><strong>Entr√©e</strong> : Un chemin et une grille</li>
            <li><strong>Sortie</strong> : Aucune (modification de la variable d'interface <code>reponse</code>)</li>
            <li><strong>R√®gle</strong> : Les 3 conditions doivent √™tre vraies simultan√©ment</li>
        </ul>
        <p><strong>Structure sugg√©r√©e</strong> :</p>
        <pre><code>if (condition1 and condition2 and condition3):
    reponse.set("Bravo")
else:
    reponse.set("Perdu")</code></pre>

        <h3>Partie II - Fonctions al√©atoires</h3>

        <h4><code>randomGrille(L, C)</code></h4>
        <p><strong>Sp√©cification</strong> :</p>
        <ul>
            <li><strong>Entr√©e</strong> : Nombre de lignes L, nombre de colonnes C</li>
            <li><strong>Sortie</strong> : Une grille L√óC avec cases al√©atoires</li>
            <li><strong>Effet de bord</strong> : Modifie <code>grillecourante</code> (variable globale)</li>
        </ul>
        <p><strong>Structure</strong> : Liste de listes (liste en compr√©hension √† deux niveaux)</p>

        <h4><code>cheminAleatoire1(grille)</code></h4>
        <p><strong>Sp√©cification</strong> :</p>
        <ul>
            <li><strong>Entr√©e</strong> : Une grille</li>
            <li><strong>Sortie</strong> : Un chemin de la case de d√©part √† <code>[0,0]</code></li>
            <li><strong>Contrainte</strong> : Ne se d√©place que vers le haut ou la gauche</li>
        </ul>
        <p><strong>Cas particuliers</strong> :</p>
        <ul>
            <li>Si <code>ligne == 0</code> : ne peut aller qu'√† gauche</li>
            <li>Si <code>colonne == 0</code> : ne peut aller qu'en haut</li>
            <li>Sinon : choix al√©atoire entre les deux</li>
        </ul>

        <h4><code>cheminAleatoire2(grille)</code></h4>
        <p><strong>Sp√©cification</strong> :</p>
        <ul>
            <li><strong>Entr√©e</strong> : Une grille</li>
            <li><strong>Sortie</strong> : Un chemin (qui peut ne pas atteindre l'arriv√©e si coinc√©)</li>
            <li><strong>Contrainte</strong> : Choisit al√©atoirement parmi les cases voisines disponibles</li>
        </ul>
        <p><strong>Optimisation</strong> : Si l'arriv√©e est dans les cases disponibles, y aller directement.</p>
        <p><strong>Gestion du blocage</strong> : La boucle s'arr√™te si <code>nextmove == []</code> (aucune case disponible).</p>

        <h4><code>initialisenew(grilleinit)</code></h4>
        <p><strong>Sp√©cification</strong> :</p>
        <ul>
            <li><strong>Entr√©e</strong> : Une nouvelle grille</li>
            <li><strong>Sortie</strong> : Aucune (modification de l'interface)</li>
            <li><strong>Actions</strong> :
                <ol>
                    <li>R√©initialiser <code>chemin</code> et <code>grillecourante</code></li>
                    <li>Supprimer les anciens boutons de la grille</li>
                    <li>Recr√©er la grille (comme <code>initialise()</code>)</li>
                </ol>
            </li>
        </ul>
        <p><strong>Astuce pour supprimer les boutons</strong> :</p>
        <pre><code>for button in fenetre.grid_slaves():
    if (conditions pour v√©rifier que c'est un bouton de la grille):
        button.destroy()</code></pre>

        <h4><code>lanceCheminAleatoire1(grille)</code> et <code>lanceCheminAleatoire2(grille)</code></h4>
        <p><strong>Sp√©cification</strong> :</p>
        <ul>
            <li><strong>Entr√©e</strong> : Une grille</li>
            <li><strong>Sortie</strong> : Aucune (modification de l'interface)</li>
            <li><strong>Actions</strong> :
                <ol>
                    <li>G√©n√©rer un chemin al√©atoire</li>
                    <li>D√©sactiver visuellement les boutons du chemin</li>
                    <li>V√©rifier si le chemin est valide</li>
                </ol>
            </li>
        </ul>
        <div class="tip">
            <strong>üí° Pattern √† suivre :</strong> Regarder <code>lanceAide()</code> qui fait la m√™me chose avec <code>chercheChemin()</code>.
        </div>
    </div>

    <hr>

    <div class="section">
        <h2>üêõ Conseils de d√©bogage</h2>

        <h3>Tests unitaires</h3>
        <p>Testez chaque fonction individuellement avant de passer √† la suivante :</p>
        <pre><code>from jeucastortravail import *

# Test 1 : Voisinage
assert sontVoisines([0,0], [0,1]) == True
assert sontVoisines([0,0], [1,1]) == False

# Test 2 : D√©part/Arriv√©e
assert departArrivee([[4,5], [0,0]], grille_1) == True
assert departArrivee([[0,0], [4,5]], grille_1) == False

# Test 3 : Chemin continu
assert cheminContinu([[4,5], [3,5], [2,5]]) == True
assert cheminContinu([[4,5], [2,5]]) == False</code></pre>

        <h3>Erreurs courantes</h3>
        <table>
            <thead>
                <tr>
                    <th>Erreur</th>
                    <th>Cause</th>
                    <th>Solution</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>return True</code> trop t√¥t</td>
                    <td><code>return</code> dans la boucle</td>
                    <td>Mettre <code>return True</code> en dehors</td>
                </tr>
                <tr>
                    <td>Variable non modifi√©e</td>
                    <td>Oublier <code>global</code></td>
                    <td>Ajouter <code>global nom_variable</code></td>
                </tr>
                <tr>
                    <td>Indices invers√©s</td>
                    <td><code>[colonne, ligne]</code></td>
                    <td>Toujours <code>[ligne, colonne]</code></td>
                </tr>
                <tr>
                    <td>Image non trouv√©e</td>
                    <td>Chemin relatif</td>
                    <td>Utiliser <code>os.path.join(SCRIPT_DIR, ...)</code></td>
                </tr>
                <tr>
                    <td>Bouton ne r√©pond pas</td>
                    <td>Lambda mal configur√©e</td>
                    <td>V√©rifier capture des variables</td>
                </tr>
            </tbody>
        </table>

        <h3>Affichage de d√©bogage</h3>
        <p>Ajoutez des <code>print()</code> pour comprendre ce qui se passe :</p>
        <pre><code>def ordreDesCases(parcours, grille):
    mot = ''
    for case in parcours:
        mot = mot + grille[case[0]][case[1]]
    print(f"Mot construit : {mot}")  # D√©bogage
    # ... suite du code</code></pre>
    </div>

    <hr>

    <div class="section">
        <h2>üìñ Ressources</h2>
        <ul>
            <li><strong>Tkinter</strong> : <a href="https://docs.python.org/fr/3/library/tkinter.html" target="_blank">https://docs.python.org/fr/3/library/tkinter.html</a></li>
            <li><strong>Module random</strong> : <a href="https://docs.python.org/fr/3/library/random.html" target="_blank">https://docs.python.org/fr/3/library/random.html</a></li>
            <li><strong>Listes en compr√©hension</strong> : <a href="https://docs.python.org/fr/3/tutorial/datastructures.html#list-comprehensions" target="_blank">https://docs.python.org/fr/3/tutorial/datastructures.html#list-comprehensions</a></li>
            <li><strong>Backtracking</strong> : <a href="https://fr.wikipedia.org/wiki/Retour_sur_trace" target="_blank">https://fr.wikipedia.org/wiki/Retour_sur_trace</a></li>
        </ul>
    </div>

    <footer style="text-align: center; margin-top: 40px; padding: 20px; background-color: #f8f9fa; border-top: 2px solid #dee2e6;">
        <p style="color: #6c757d;">üìö Documentation du projet "Parcours du Castor" - NSI</p>
    </footer>
</body>
</html>
